--
geom_abline.html
Reference lines: horizontal, vertical, and diagonal
Source: R/geom-abline.r, R/geom-hline.r, R/geom-vline.r
These geoms add reference lines (sometimes called rules) to a plot, either horizontal, vertical, or diagonal (specified by slope and intercept). These are useful for annotating plots.

geom_abline(
  mapping = NULL,
  data = NULL,
  ...,
  slope,
  intercept,
  na.rm = FALSE,
  show.legend = NA
)

geom_hline(
  mapping = NULL,
  data = NULL,
  ...,
  yintercept,
  na.rm = FALSE,
  show.legend = NA
)

geom_vline(
  mapping = NULL,
  data = NULL,
  ...,
  xintercept,
  na.rm = FALSE,
  show.legend = NA
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_().

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

xintercept, yintercept, slope, intercept	
Parameters that control the position of the line. If these are set, data, mapping and show.legend are overridden.

Details
These geoms act slightly differently from other geoms. You can supply the parameters in two ways: either as arguments to the layer function, or via aesthetics. If you use arguments, e.g. geom_abline(intercept = 0, slope = 1), then behind the scenes the geom makes a new data frame containing just the data you've supplied. That means that the lines will be the same in all facets; if you want them to vary across facets, construct the data frame yourself and use aesthetics.

Unlike most other geoms, these geoms do not inherit aesthetics from the plot default, because they do not understand x and y aesthetics which are commonly set in the plot. They also do not affect the x and y scales.

Aesthetics
These geoms are drawn using with geom_line() so support the same aesthetics: alpha, colour, linetype and size. They also each have aesthetics that control the position of the line:

geom_vline(): xintercept

geom_hline(): yintercept

geom_abline(): slope and intercept

See also
See geom_segment() for a more general approach to adding straight line segments to a plot.

Examples
p <- cxplot(mtcars, aes(wt, mpg)) + geom_point()

# Fixed values
p + geom_vline(xintercept = 5)

p + geom_vline(xintercept = 1:5)

p + geom_hline(yintercept = 20)


p + geom_abline() # Can't see it - outside the range of the data

p + geom_abline(intercept = 20)


# Calculate slope and intercept of line of best fit
coef(lm(mpg ~ wt, data = mtcars))
#> (Intercept)          wt 
#>   37.285126   -5.344472 
p + geom_abline(intercept = 37, slope = -5)

# But this is easier to do with geom_smooth:
p + geom_smooth(method = "lm", se = FALSE)
#> `geom_smooth()` using formula 'y ~ x'


# To show different lines in different facets, use aesthetics
p <- cxplot(mtcars, aes(mpg, wt)) +
  geom_point() +
  facet_wrap(~ cyl)

mean_wt <- data.frame(cyl = c(4, 6, 8), wt = c(2.28, 3.11, 4.00))
p + geom_hline(aes(yintercept = wt), mean_wt)


# You can also control other aesthetics
cxplot(mtcars, aes(mpg, wt, colour = wt)) +
  geom_point() +
  geom_hline(aes(yintercept = wt, colour = wt), mean_wt) +
  facet_wrap(~ cyl)

--
geom_bar.html
Bar charts
Source: R/geom-bar.r, R/geom-col.r, R/stat-count.r
There are two types of bar charts: geom_bar() and geom_col(). geom_bar() makes the height of the bar proportional to the number of cases in each group (or if the weight aesthetic is supplied, the sum of the weights). If you want the heights of the bars to represent values in the data, use geom_col() instead. geom_bar() uses stat_count() by default: it counts the number of cases at each x position. geom_col() uses stat_identity(): it leaves the data as is.

geom_bar(
  mapping = NULL,
  data = NULL,
  stat = "count",
  position = "stack",
  ...,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_col(
  mapping = NULL,
  data = NULL,
  position = "stack",
  ...,
  width = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_count(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "stack",
  ...,
  width = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

width	
Bar width. By default, set to 90% of the resolution of the data.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

orientation	
The orientation of the layer. The default (NA) automatically determines the orientation from the aesthetic mapping. In the rare event that this fails it can be given explicitly by setting orientation to either "x" or "y". See the Orientation section for more detail.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

geom, stat	
Override the default connection between geom_bar() and stat_count().

Details
A bar chart uses height to represent a value, and so the base of the bar must always be shown to produce a valid visual comparison. Proceed with caution when using transformed scales with a bar chart. It's important to always use a meaningful reference point for the base of the bar. For example, for log transformations the reference point is 1. In fact, when using a log scale, geom_bar() automatically places the base of the bar at 1. Furthermore, never use stacked bars with a transformed scale, because scaling happens before stacking. As a consequence, the height of bars will be wrong when stacking occurs with a transformed scale.

By default, multiple bars occupying the same x position will be stacked atop one another by position_stack(). If you want them to be dodged side-to-side, use position_dodge() or position_dodge2(). Finally, position_fill() shows relative proportions at each x by stacking the bars and then standardising each bar to have the same height.

Orientation
This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, cxplot will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the orientation parameter, which can be either "x" or "y". The value gives the axis that the geom should run along, "x" being the default orientation you would expect for the geom.

Aesthetics
geom_bar() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

linetype

size

Learn more about setting these aesthetics in vignette("cxplot-specs").

geom_col() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

linetype

size

Learn more about setting these aesthetics in vignette("cxplot-specs").

stat_count() understands the following aesthetics (required aesthetics are in bold):

x or y

group

weight

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
count
number of points in bin

prop
groupwise proportion

See also
geom_histogram() for continuous data, position_dodge() and position_dodge2() for creating side-by-side bar charts.

stat_bin(), which bins data in ranges and counts the cases in each range. It differs from stat_count(), which counts the number of cases at each x position (without binning into ranges). stat_bin() requires continuous x data, whereas stat_count() can be used for both discrete and continuous x data.

Examples
# geom_bar is designed to make it easy to create bar charts that show
# counts (or sums of weights)
g <- cxplot(mpg, aes(class))
# Number of cars in each class:
g + geom_bar()

# Total engine displacement of each class
g + geom_bar(aes(weight = displ))

# Map class to y instead to flip the orientation
cxplot(mpg) + geom_bar(aes(y = class))


# Bar charts are automatically stacked when multiple bars are placed
# at the same location. The order of the fill is designed to match
# the legend
g + geom_bar(aes(fill = drv))


# If you need to flip the order (because you've flipped the orientation)
# call position_stack() explicitly:
cxplot(mpg, aes(y = class)) +
 geom_bar(aes(fill = drv), position = position_stack(reverse = TRUE)) +
 theme(legend.position = "top")


# To show (e.g.) means, you need geom_col()
df <- data.frame(trt = c("a", "b", "c"), outcome = c(2.3, 1.9, 3.2))
cxplot(df, aes(trt, outcome)) +
  geom_col()

# But geom_point() displays exactly the same information and doesn't
# require the y-axis to touch zero.
cxplot(df, aes(trt, outcome)) +
  geom_point()


# You can also use geom_bar() with continuous data, in which case
# it will show counts at unique locations
df <- data.frame(x = rep(c(2.9, 3.1, 4.5), c(5, 10, 4)))
cxplot(df, aes(x)) + geom_bar()

# cf. a histogram of the same data
cxplot(df, aes(x)) + geom_histogram(binwidth = 0.5)

--
geom_boxplot.html
A box and whiskers plot (in the style of Tukey)
Source: R/geom-boxplot.r, R/stat-boxplot.r
The boxplot compactly displays the distribution of a continuous variable. It visualises five summary statistics (the median, two hinges and two whiskers), and all "outlying" points individually.

geom_boxplot(
  mapping = NULL,
  data = NULL,
  stat = "boxplot",
  position = "dodge2",
  ...,
  outlier.colour = NULL,
  outlier.color = NULL,
  outlier.fill = NULL,
  outlier.shape = 19,
  outlier.size = 1.5,
  outlier.stroke = 0.5,
  outlier.alpha = NULL,
  notch = FALSE,
  notchwidth = 0.5,
  varwidth = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_boxplot(
  mapping = NULL,
  data = NULL,
  geom = "boxplot",
  position = "dodge2",
  ...,
  coef = 1.5,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

outlier.colour, outlier.color, outlier.fill, outlier.shape, outlier.size, outlier.stroke, outlier.alpha	
Default aesthetics for outliers. Set to NULL to inherit from the aesthetics used for the box.

In the unlikely event you specify both US and UK spellings of colour, the US spelling will take precedence.

Sometimes it can be useful to hide the outliers, for example when overlaying the raw data points on top of the boxplot. Hiding the outliers can be achieved by setting outlier.shape = NA. Importantly, this does not remove the outliers, it only hides them, so the range calculated for the y-axis will be the same with outliers shown and outliers hidden.

notch	
If FALSE (default) make a standard box plot. If TRUE, make a notched box plot. Notches are used to compare groups; if the notches of two boxes do not overlap, this suggests that the medians are significantly different.

notchwidth	
For a notched box plot, width of the notch relative to the body (defaults to notchwidth = 0.5).

varwidth	
If FALSE (default) make a standard box plot. If TRUE, boxes are drawn with widths proportional to the square-roots of the number of observations in the groups (possibly weighted, using the weight aesthetic).

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

orientation	
The orientation of the layer. The default (NA) automatically determines the orientation from the aesthetic mapping. In the rare event that this fails it can be given explicitly by setting orientation to either "x" or "y". See the Orientation section for more detail.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

geom, stat	
Use to override the default connection between geom_boxplot() and stat_boxplot().

coef	
Length of the whiskers as multiple of IQR. Defaults to 1.5.

Orientation
This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, cxplot will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the orientation parameter, which can be either "x" or "y". The value gives the axis that the geom should run along, "x" being the default orientation you would expect for the geom.

Summary statistics
The lower and upper hinges correspond to the first and third quartiles (the 25th and 75th percentiles). This differs slightly from the method used by the boxplot() function, and may be apparent with small samples. See boxplot.stats() for for more information on how hinge positions are calculated for boxplot().

The upper whisker extends from the hinge to the largest value no further than 1.5 * IQR from the hinge (where IQR is the inter-quartile range, or distance between the first and third quartiles). The lower whisker extends from the hinge to the smallest value at most 1.5 * IQR of the hinge. Data beyond the end of the whiskers are called "outlying" points and are plotted individually.

In a notched box plot, the notches extend 1.58 * IQR / sqrt(n). This gives a roughly 95% confidence interval for comparing medians. See McGill et al. (1978) for more details.

Aesthetics
geom_boxplot() understands the following aesthetics (required aesthetics are in bold):

x or y

lower or xlower

upper or xupper

middle or xmiddle

ymin or xmin

ymax or xmax

alpha

colour

fill

group

linetype

shape

size

weight

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
stat_boxplot() provides the following variables, some of which depend on the orientation:

width
width of boxplot

ymin or xmin
lower whisker = smallest observation greater than or equal to lower hinge - 1.5 * IQR

lower or xlower
lower hinge, 25% quantile

notchlower
lower edge of notch = median - 1.58 * IQR / sqrt(n)

middle or xmiddle
median, 50% quantile

notchupper
upper edge of notch = median + 1.58 * IQR / sqrt(n)

upper or xupper
upper hinge, 75% quantile

ymax or xmax
upper whisker = largest observation less than or equal to upper hinge + 1.5 * IQR

References
McGill, R., Tukey, J. W. and Larsen, W. A. (1978) Variations of box plots. The American Statistician 32, 12-16.

See also
geom_quantile() for continuous x, geom_violin() for a richer display of the distribution, and geom_jitter() for a useful technique for small data.

Examples
p <- cxplot(mpg, aes(class, hwy))
p + geom_boxplot()

# Orientation follows the discrete axis
cxplot(mpg, aes(hwy, class)) + geom_boxplot()


p + geom_boxplot(notch = TRUE)
#> notch went outside hinges. Try setting notch=FALSE.
#> notch went outside hinges. Try setting notch=FALSE.

p + geom_boxplot(varwidth = TRUE)

p + geom_boxplot(fill = "white", colour = "#3366FF")

# By default, outlier points match the colour of the box. Use
# outlier.colour to override
p + geom_boxplot(outlier.colour = "red", outlier.shape = 1)

# Remove outliers when overlaying boxplot with original data points
p + geom_boxplot(outlier.shape = NA) + geom_jitter(width = 0.2)


# Boxplots are automatically dodged when any aesthetic is a factor
p + geom_boxplot(aes(colour = drv))


# You can also use boxplots with continuous x, as long as you supply
# a grouping variable. cut_width is particularly useful
cxplot(diamonds, aes(carat, price)) +
  geom_boxplot()
#> Warning: Continuous x aesthetic -- did you forget aes(group=...)?

cxplot(diamonds, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.25)))

# Adjust the transparency of outliers using outlier.alpha
cxplot(diamonds, aes(carat, price)) +
  geom_boxplot(aes(group = cut_width(carat, 0.25)), outlier.alpha = 0.1)


# \donttest{
# It's possible to draw a boxplot with your own computations if you
# use stat = "identity":
y <- rnorm(100)
df <- data.frame(
  x = 1,
  y0 = min(y),
  y25 = quantile(y, 0.25),
  y50 = median(y),
  y75 = quantile(y, 0.75),
  y100 = max(y)
)
cxplot(df, aes(x)) +
  geom_boxplot(
   aes(ymin = y0, lower = y25, middle = y50, upper = y75, ymax = y100),
   stat = "identity"
 )

# }

--
geom_contour.html
2D contours of a 3D surface
Source: R/geom-contour.r, R/stat-contour.r
cxplot can not draw true 3D surfaces, but you can use geom_contour(), geom_contour_filled(), and geom_tile() to visualise 3D surfaces in 2D. To specify a valid surface, the data must contain x, y, and z coordinates, and each unique combination of x and y can appear at most once. Contouring requires that the points can be rearranged so that the z values form a matrix, with rows corresponding to unique x values, and columns corresponding to unique y values. Missing entries are allowed, but contouring will only be done on cells of the grid with all four z values present. If your data is irregular, you can interpolate to a grid before visualising using the interp::interp() function from the interp package (or one of the interpolating functions from the akima package.)

geom_contour(
  mapping = NULL,
  data = NULL,
  stat = "contour",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_contour_filled(
  mapping = NULL,
  data = NULL,
  stat = "contour_filled",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_contour(
  mapping = NULL,
  data = NULL,
  geom = "contour",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_contour_filled(
  mapping = NULL,
  data = NULL,
  geom = "contour_filled",
  position = "identity",
  ...,
  bins = NULL,
  binwidth = NULL,
  breaks = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

stat	
The statistical transformation to use on the data for this layer, as a string.

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

bins	
Number of contour bins. Overridden by binwidth.

binwidth	
The width of the contour bins. Overridden by breaks.

breaks	
Numeric vector to set the contour breaks. Overrides binwidth and bins. By default, this is a vector of length ten with pretty() breaks.

lineend	
Line end style (round, butt, square).

linejoin	
Line join style (round, mitre, bevel).

linemitre	
Line mitre limit (number greater than 1).

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

geom	
The geometric object to use display the data

Aesthetics
geom_contour() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

group

linetype

size

weight

Learn more about setting these aesthetics in vignette("cxplot-specs").

geom_contour_filled() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

linetype

size

subgroup

Learn more about setting these aesthetics in vignette("cxplot-specs").

stat_contour() understands the following aesthetics (required aesthetics are in bold):

x

y

z

group

order

Learn more about setting these aesthetics in vignette("cxplot-specs").

stat_contour_filled() understands the following aesthetics (required aesthetics are in bold):

x

y

z

fill

group

order

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
The computed variables differ somewhat for contour lines (computed by stat_contour()) and contour bands (filled contours, computed by stat_contour_filled()). The variables nlevel and piece are available for both, whereas level_low, level_high, and level_mid are only available for bands. The variable level is a numeric or a factor depending on whether lines or bands are calculated.

level
Height of contour. For contour lines, this is numeric vector that represents bin boundaries. For contour bands, this is an ordered factor that represents bin ranges.

level_low, level_high, level_mid
(contour bands only) Lower and upper bin boundaries for each band, as well the mid point between the boundaries.

nlevel
Height of contour, scaled to maximum of 1.

piece
Contour piece (an integer).

See also
geom_density_2d(): 2d density contours

Examples
# Basic plot
v <- cxplot(faithfuld, aes(waiting, eruptions, z = density))
v + geom_contour()


# Or compute from raw data
cxplot(faithful, aes(waiting, eruptions)) +
  geom_density_2d()


# \donttest{
# use geom_contour_filled() for filled contours
v + geom_contour_filled()


# Setting bins creates evenly spaced contours in the range of the data
v + geom_contour(bins = 3)

v + geom_contour(bins = 5)


# Setting binwidth does the same thing, parameterised by the distance
# between contours
v + geom_contour(binwidth = 0.01)

v + geom_contour(binwidth = 0.001)


# Other parameters
v + geom_contour(aes(colour = after_stat(level)))

v + geom_contour(colour = "red")

v + geom_raster(aes(fill = density)) +
  geom_contour(colour = "white")


# Irregular data
if (requireNamespace("interp")) {
  # Use a dataset from the interp package
  data(franke, package = "interp")
  origdata <- as.data.frame(interp::franke.data(1, 1, franke))
  grid <- with(origdata, interp::interp(x, y, z))
  griddf <- subset(data.frame(x = rep(grid$x, nrow(grid$z)),
                              y = rep(grid$y, each = ncol(grid$z)),
                              z = as.numeric(grid$z)),
                   !is.na(z))
  cxplot(griddf, aes(x, y, z = z)) +
    geom_contour_filled() +
    geom_point(data = origdata)
} else
  message("Irregular data requires the 'interp' package")
#> Loading required namespace: interp

# }

--
geom_density.html
Smoothed density estimates
Source: R/geom-density.r, R/stat-density.r
Computes and draws kernel density estimate, which is a smoothed version of the histogram. This is a useful alternative to the histogram for continuous data that comes from an underlying smooth distribution.

geom_density(
  mapping = NULL,
  data = NULL,
  stat = "density",
  position = "identity",
  ...,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  outline.type = "upper"
)

stat_density(
  mapping = NULL,
  data = NULL,
  geom = "area",
  position = "stack",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  n = 512,
  trim = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

orientation	
The orientation of the layer. The default (NA) automatically determines the orientation from the aesthetic mapping. In the rare event that this fails it can be given explicitly by setting orientation to either "x" or "y". See the Orientation section for more detail.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

outline.type	
Type of the outline of the area; "both" draws both the upper and lower lines, "upper"/"lower" draws the respective lines only. "full" draws a closed polygon around the area.

geom, stat	
Use to override the default connection between geom_density() and stat_density().

bw	
The smoothing bandwidth to be used. If numeric, the standard deviation of the smoothing kernel. If character, a rule to choose the bandwidth, as listed in stats::bw.nrd().

adjust	
A multiplicate bandwidth adjustment. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For example, adjust = 1/2 means use half of the default bandwidth.

kernel	
Kernel. See list of available kernels in density().

n	
number of equally spaced points at which the density is to be estimated, should be a power of two, see density() for details

trim	
If FALSE, the default, each density is computed on the full range of the data. If TRUE, each density is computed over the range of that group: this typically means the estimated x values will not line-up, and hence you won't be able to stack density values. This parameter only matters if you are displaying multiple densities in one plot or if you are manually adjusting the scale limits.

Orientation
This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, cxplot will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the orientation parameter, which can be either "x" or "y". The value gives the axis that the geom should run along, "x" being the default orientation you would expect for the geom.

Aesthetics
geom_density() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

linetype

size

weight

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
density
density estimate

count
density * number of points - useful for stacked density plots

scaled
density estimate, scaled to maximum of 1

ndensity
alias for scaled, to mirror the syntax of stat_bin()

See also
See geom_histogram(), geom_freqpoly() for other methods of displaying continuous distribution. See geom_violin() for a compact density display.

Examples
cxplot(diamonds, aes(carat)) +
  geom_density()

# Map the values to y to flip the orientation
cxplot(diamonds, aes(y = carat)) +
  geom_density()


cxplot(diamonds, aes(carat)) +
  geom_density(adjust = 1/5)

cxplot(diamonds, aes(carat)) +
  geom_density(adjust = 5)


cxplot(diamonds, aes(depth, colour = cut)) +
  geom_density() +
  xlim(55, 70)
#> Warning: Removed 45 rows containing non-finite values (stat_density).

cxplot(diamonds, aes(depth, fill = cut, colour = cut)) +
  geom_density(alpha = 0.1) +
  xlim(55, 70)
#> Warning: Removed 45 rows containing non-finite values (stat_density).


# \donttest{
# Stacked density plots: if you want to create a stacked density plot, you
# probably want to 'count' (density * n) variable instead of the default
# density

# Loses marginal densities
cxplot(diamonds, aes(carat, fill = cut)) +
  geom_density(position = "stack")

# Preserves marginal densities
cxplot(diamonds, aes(carat, after_stat(count), fill = cut)) +
  geom_density(position = "stack")


# You can use position="fill" to produce a conditional density estimate
cxplot(diamonds, aes(carat, after_stat(count), fill = cut)) +
  geom_density(position = "fill")

# }

--
geom_density_2d.html
Contours of a 2D density estimate
Source: R/geom-density2d.r, R/stat-density-2d.r
Perform a 2D kernel density estimation using MASS::kde2d() and display the results with contours. This can be useful for dealing with overplotting. This is a 2D version of geom_density(). geom_density_2d() draws contour lines, and geom_density_2d_filled() draws filled contour bands.

geom_density_2d(
  mapping = NULL,
  data = NULL,
  stat = "density_2d",
  position = "identity",
  ...,
  contour_var = "density",
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_density_2d_filled(
  mapping = NULL,
  data = NULL,
  stat = "density_2d_filled",
  position = "identity",
  ...,
  contour_var = "density",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_density_2d(
  mapping = NULL,
  data = NULL,
  geom = "density_2d",
  position = "identity",
  ...,
  contour = TRUE,
  contour_var = "density",
  n = 100,
  h = NULL,
  adjust = c(1, 1),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_density_2d_filled(
  mapping = NULL,
  data = NULL,
  geom = "density_2d_filled",
  position = "identity",
  ...,
  contour = TRUE,
  contour_var = "density",
  n = 100,
  h = NULL,
  adjust = c(1, 1),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Arguments passed on to geom_contour

bins
Number of contour bins. Overridden by binwidth.

binwidth
The width of the contour bins. Overridden by breaks.

breaks
Numeric vector to set the contour breaks. Overrides binwidth and bins. By default, this is a vector of length ten with pretty() breaks.

contour_var	
Character string identifying the variable to contour by. Can be one of "density", "ndensity", or "count". See the section on computed variables for details.

lineend	
Line end style (round, butt, square).

linejoin	
Line join style (round, mitre, bevel).

linemitre	
Line mitre limit (number greater than 1).

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

geom, stat	
Use to override the default connection between geom_density_2d() and stat_density_2d().

contour	
If TRUE, contour the results of the 2d density estimation.

n	
Number of grid points in each direction.

h	
Bandwidth (vector of length two). If NULL, estimated using MASS::bandwidth.nrd().

adjust	
A multiplicative bandwidth adjustment to be used if 'h' is 'NULL'. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For example, adjust = 1/2 means use half of the default bandwidth.

Aesthetics
geom_density_2d() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

group

linetype

size

Learn more about setting these aesthetics in vignette("cxplot-specs").

geom_density_2d_filled() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

linetype

size

subgroup

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
stat_density_2d() and stat_density_2d_filled() compute different variables depending on whether contouring is turned on or off. With contouring off (contour = FALSE), both stats behave the same, and the following variables are provided:

density
The density estimate.

ndensity
Density estimate, scaled to a maximum of 1.

count
Density estimate * number of observations in group.

n
Number of observations in each group.

With contouring on (contour = TRUE), either stat_contour() or stat_contour_filled() (for contour lines or contour bands, respectively) is run after the density estimate has been obtained, and the computed variables are determined by these stats. Contours are calculated for one of the three types of density estimates obtained before contouring, density, ndensity, and count. Which of those should be used is determined by the contour_var parameter.

See also
geom_contour(), geom_contour_filled() for information about how contours are drawn; geom_bin2d() for another way of dealing with overplotting.

Examples
m <- cxplot(faithful, aes(x = eruptions, y = waiting)) +
 geom_point() +
 xlim(0.5, 6) +
 ylim(40, 110)

# contour lines
m + geom_density_2d()


# \donttest{
# contour bands
m + geom_density_2d_filled(alpha = 0.5)


# contour bands and contour lines
m + geom_density_2d_filled(alpha = 0.5) +
  geom_density_2d(size = 0.25, colour = "black")


set.seed(4393)
dsmall <- diamonds[sample(nrow(diamonds), 1000), ]
d <- cxplot(dsmall, aes(x, y))
# If you map an aesthetic to a categorical variable, you will get a
# set of contours for each value of that variable
d + geom_density_2d(aes(colour = cut))


# If you draw filled contours across multiple facets, the same bins are
# used across all facets
d + geom_density_2d_filled() + facet_wrap(vars(cut))

# If you want to make sure the peak intensity is the same in each facet,
# use `contour_var = "ndensity"`.
d + geom_density_2d_filled(contour_var = "ndensity") + facet_wrap(vars(cut))

# If you want to scale intensity by the number of observations in each group,
# use `contour_var = "count"`.
d + geom_density_2d_filled(contour_var = "count") + facet_wrap(vars(cut))


# If we turn contouring off, we can use other geoms, such as tiles:
d + stat_density_2d(
  geom = "raster",
  aes(fill = after_stat(density)),
  contour = FALSE
) + scale_fill_viridis_c()

# Or points:
d + stat_density_2d(geom = "point", aes(size = after_stat(density)), n = 20, contour = FALSE)

# }

--
geom_histogram.html
Histograms and frequency polygons
Source: R/geom-freqpoly.r, R/geom-histogram.r, R/stat-bin.r
Visualise the distribution of a single continuous variable by dividing the x axis into bins and counting the number of observations in each bin. Histograms (geom_histogram()) display the counts with bars; frequency polygons (geom_freqpoly()) display the counts with lines. Frequency polygons are more suitable when you want to compare the distribution across the levels of a categorical variable.

geom_freqpoly(
  mapping = NULL,
  data = NULL,
  stat = "bin",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_histogram(
  mapping = NULL,
  data = NULL,
  stat = "bin",
  position = "stack",
  ...,
  binwidth = NULL,
  bins = NULL,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_bin(
  mapping = NULL,
  data = NULL,
  geom = "bar",
  position = "stack",
  ...,
  binwidth = NULL,
  bins = NULL,
  center = NULL,
  boundary = NULL,
  breaks = NULL,
  closed = c("right", "left"),
  pad = FALSE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

binwidth	
The width of the bins. Can be specified as a numeric value or as a function that calculates width from unscaled x. Here, "unscaled x" refers to the original x values in the data, before application of any scale transformation. When specifying a function along with a grouping structure, the function will be called once per group. The default is to use the number of bins in bins, covering the range of the data. You should always override this value, exploring multiple widths to find the best to illustrate the stories in your data.

The bin width of a date variable is the number of days in each time; the bin width of a time variable is the number of seconds.

bins	
Number of bins. Overridden by binwidth. Defaults to 30.

orientation	
The orientation of the layer. The default (NA) automatically determines the orientation from the aesthetic mapping. In the rare event that this fails it can be given explicitly by setting orientation to either "x" or "y". See the Orientation section for more detail.

geom, stat	
Use to override the default connection between geom_histogram()/geom_freqpoly() and stat_bin().

center, boundary	
bin position specifiers. Only one, center or boundary, may be specified for a single plot. center specifies the center of one of the bins. boundary specifies the boundary between two bins. Note that if either is above or below the range of the data, things will be shifted by the appropriate integer multiple of binwidth. For example, to center on integers use binwidth = 1 and center = 0, even if 0 is outside the range of the data. Alternatively, this same alignment can be specified with binwidth = 1 and boundary = 0.5, even if 0.5 is outside the range of the data.

breaks	
Alternatively, you can supply a numeric vector giving the bin boundaries. Overrides binwidth, bins, center, and boundary.

closed	
One of "right" or "left" indicating whether right or left edges of bins are included in the bin.

pad	
If TRUE, adds empty bins at either end of x. This ensures frequency polygons touch 0. Defaults to FALSE.

Details
stat_bin() is suitable only for continuous x data. If your x data is discrete, you probably want to use stat_count().

By default, the underlying computation (stat_bin()) uses 30 bins; this is not a good default, but the idea is to get you experimenting with different number of bins. You can also experiment modifying the binwidth with center or boundary arguments. binwidth overrides bins so you should do one change at a time. You may need to look at a few options to uncover the full story behind your data.

In addition to geom_histogram(), you can create a histogram plot by using scale_x_binned() with geom_bar(). This method by default plots tick marks in between each bar.

Orientation
This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, cxplot will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the orientation parameter, which can be either "x" or "y". The value gives the axis that the geom should run along, "x" being the default orientation you would expect for the geom.

Aesthetics
geom_histogram() uses the same aesthetics as geom_bar(); geom_freqpoly() uses the same aesthetics as geom_line().

Computed variables
count
number of points in bin

density
density of points in bin, scaled to integrate to 1

ncount
count, scaled to maximum of 1

ndensity
density, scaled to maximum of 1

width
widths of bins

See also
stat_count(), which counts the number of cases at each x position, without binning. It is suitable for both discrete and continuous x data, whereas stat_bin() is suitable only for continuous x data.

Examples
cxplot(diamonds, aes(carat)) +
  geom_histogram()
#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.

cxplot(diamonds, aes(carat)) +
  geom_histogram(binwidth = 0.01)

cxplot(diamonds, aes(carat)) +
  geom_histogram(bins = 200)

# Map values to y to flip the orientation
cxplot(diamonds, aes(y = carat)) +
  geom_histogram()
#> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`.


# For histograms with tick marks between each bin, use `geom_bar()` with
# `scale_x_binned()`.
cxplot(diamonds, aes(carat)) +
  geom_bar() +
  scale_x_binned()


# Rather than stacking histograms, it's easier to compare frequency
# polygons
cxplot(diamonds, aes(price, fill = cut)) +
  geom_histogram(binwidth = 500)

cxplot(diamonds, aes(price, colour = cut)) +
  geom_freqpoly(binwidth = 500)


# To make it easier to compare distributions with very different counts,
# put density on the y axis instead of the default count
cxplot(diamonds, aes(price, after_stat(density), colour = cut)) +
  geom_freqpoly(binwidth = 500)


if (require("cxplotmovies")) {
# Often we don't want the height of the bar to represent the
# count of observations, but the sum of some other variable.
# For example, the following plot shows the number of movies
# in each rating.
m <- cxplot(movies, aes(rating))
m + geom_histogram(binwidth = 0.1)

# If, however, we want to see the number of votes cast in each
# category, we need to weight by the votes variable
m +
  geom_histogram(aes(weight = votes), binwidth = 0.1) +
  ylab("votes")

# For transformed scales, binwidth applies to the transformed data.
# The bins have constant width on the transformed scale.
m +
 geom_histogram() +
 scale_x_log10()
m +
  geom_histogram(binwidth = 0.05) +
  scale_x_log10()

# For transformed coordinate systems, the binwidth applies to the
# raw data. The bins have constant width on the original scale.

# Using log scales does not work here, because the first
# bar is anchored at zero, and so when transformed becomes negative
# infinity. This is not a problem when transforming the scales, because
# no observations have 0 ratings.
m +
  geom_histogram(boundary = 0) +
  coord_trans(x = "log10")
# Use boundary = 0, to make sure we don't take sqrt of negative values
m +
  geom_histogram(boundary = 0) +
  coord_trans(x = "sqrt")

# You can also transform the y axis.  Remember that the base of the bars
# has value 0, so log transformations are not appropriate
m <- cxplot(movies, aes(x = rating))
m +
  geom_histogram(binwidth = 0.5) +
  scale_y_sqrt()
}


# You can specify a function for calculating binwidth, which is
# particularly useful when faceting along variables with
# different ranges because the function will be called once per facet
cxplot(economics_long, aes(value)) +
  facet_wrap(~variable, scales = 'free_x') +
  geom_histogram(binwidth = function(x) 2 * IQR(x) / (length(x)^(1/3)))

--
geom_jitter.html
Jittered points
Source: R/geom-jitter.r
The jitter geom is a convenient shortcut for geom_point(position = "jitter"). It adds a small amount of random variation to the location of each point, and is a useful way of handling overplotting caused by discreteness in smaller datasets.

geom_jitter(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "jitter",
  ...,
  width = NULL,
  height = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

stat	
The statistical transformation to use on the data for this layer, as a string.

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

width	
Amount of vertical and horizontal jitter. The jitter is added in both positive and negative directions, so the total spread is twice the value specified here.

If omitted, defaults to 40% of the resolution of the data: this means the jitter values will occupy 80% of the implied bins. Categorical data is aligned on the integers, so a width or height of 0.5 will spread the data so it's not possible to see the distinction between the categories.

height	
Amount of vertical and horizontal jitter. The jitter is added in both positive and negative directions, so the total spread is twice the value specified here.

If omitted, defaults to 40% of the resolution of the data: this means the jitter values will occupy 80% of the implied bins. Categorical data is aligned on the integers, so a width or height of 0.5 will spread the data so it's not possible to see the distinction between the categories.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

Aesthetics
geom_point() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

shape

size

stroke

Learn more about setting these aesthetics in vignette("cxplot-specs").

See also
geom_point() for regular, unjittered points, geom_boxplot() for another way of looking at the conditional distribution of a variable

Examples
p <- cxplot(mpg, aes(cyl, hwy))
p + geom_point()

p + geom_jitter()


# Add aesthetic mappings
p + geom_jitter(aes(colour = class))


# Use smaller width/height to emphasise categories
cxplot(mpg, aes(cyl, hwy)) +
  geom_jitter()

cxplot(mpg, aes(cyl, hwy)) +
  geom_jitter(width = 0.25)


# Use larger width/height to completely smooth away discreteness
cxplot(mpg, aes(cty, hwy)) +
  geom_jitter()

cxplot(mpg, aes(cty, hwy)) +
  geom_jitter(width = 0.5, height = 0.5)

--
geom_path.html
Connect observations
Source: R/geom-path.r
geom_path() connects the observations in the order in which they appear in the data. geom_line() connects them in order of the variable on the x axis. geom_step() creates a stairstep plot, highlighting exactly when changes occur. The group aesthetic determines which cases are connected together.

geom_path(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  arrow = NULL,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_line(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_step(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  direction = "hv",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

stat	
The statistical transformation to use on the data for this layer, as a string.

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

lineend	
Line end style (round, butt, square).

linejoin	
Line join style (round, mitre, bevel).

linemitre	
Line mitre limit (number greater than 1).

arrow	
Arrow specification, as created by grid::arrow().

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

orientation	
The orientation of the layer. The default (NA) automatically determines the orientation from the aesthetic mapping. In the rare event that this fails it can be given explicitly by setting orientation to either "x" or "y". See the Orientation section for more detail.

direction	
direction of stairs: 'vh' for vertical then horizontal, 'hv' for horizontal then vertical, or 'mid' for step half-way between adjacent x-values.

Details
An alternative parameterisation is geom_segment(), where each line corresponds to a single case which provides the start and end coordinates.

Orientation
This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, cxplot will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the orientation parameter, which can be either "x" or "y". The value gives the axis that the geom should run along, "x" being the default orientation you would expect for the geom.

Aesthetics
geom_path() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

group

linetype

size

Learn more about setting these aesthetics in vignette("cxplot-specs").

Missing value handling
geom_path(), geom_line(), and geom_step() handle NA as follows:

If an NA occurs in the middle of a line, it breaks the line. No warning is shown, regardless of whether na.rm is TRUE or FALSE.

If an NA occurs at the start or the end of the line and na.rm is FALSE (default), the NA is removed with a warning.

If an NA occurs at the start or the end of the line and na.rm is TRUE, the NA is removed silently, without warning.

See also
geom_polygon(): Filled paths (polygons); geom_segment(): Line segments

Examples
# geom_line() is suitable for time series
cxplot(economics, aes(date, unemploy)) + geom_line()

cxplot(economics_long, aes(date, value01, colour = variable)) +
  geom_line()


# You can get a timeseries that run vertically by setting the orientation
cxplot(economics, aes(unemploy, date)) + geom_line(orientation = "y")


# geom_step() is useful when you want to highlight exactly when
# the y value changes
recent <- economics[economics$date > as.Date("2013-01-01"), ]
cxplot(recent, aes(date, unemploy)) + geom_line()

cxplot(recent, aes(date, unemploy)) + geom_step()


# geom_path lets you explore how two variables are related over time,
# e.g. unemployment and personal savings rate
m <- cxplot(economics, aes(unemploy/pop, psavert))
m + geom_path()

m + geom_path(aes(colour = as.numeric(date)))


# Changing parameters ----------------------------------------------
cxplot(economics, aes(date, unemploy)) +
  geom_line(colour = "red")


# Use the arrow parameter to add an arrow to the line
# See ?arrow for more details
c <- cxplot(economics, aes(x = date, y = pop))
c + geom_line(arrow = arrow())

c + geom_line(
  arrow = arrow(angle = 15, ends = "both", type = "closed")
)


# Control line join parameters
df <- data.frame(x = 1:3, y = c(4, 1, 9))
base <- cxplot(df, aes(x, y))
base + geom_path(size = 10)

base + geom_path(size = 10, lineend = "round")

base + geom_path(size = 10, linejoin = "mitre", lineend = "butt")


# You can use NAs to break the line.
df <- data.frame(x = 1:5, y = c(1, 2, NA, 4, 5))
cxplot(df, aes(x, y)) + geom_point() + geom_line()
#> Warning: Removed 1 rows containing missing values (geom_point).


# \donttest{
# Setting line type vs colour/size
# Line type needs to be applied to a line as a whole, so it can
# not be used with colour or size that vary across a line
x <- seq(0.01, .99, length.out = 100)
df <- data.frame(
  x = rep(x, 2),
  y = c(qlogis(x), 2 * qlogis(x)),
  group = rep(c("a","b"),
  each = 100)
)
p <- cxplot(df, aes(x=x, y=y, group=group))
# These work
p + geom_line(linetype = 2)

p + geom_line(aes(colour = group), linetype = 2)

p + geom_line(aes(colour = x))

# But this doesn't
should_stop(p + geom_line(aes(colour = x), linetype=2))

# }

--
geom_point.html
Points
Source: R/geom-point.r
The point geom is used to create scatterplots. The scatterplot is most useful for displaying the relationship between two continuous variables. It can be used to compare one continuous and one categorical variable, or two categorical variables, but a variation like geom_jitter(), geom_count(), or geom_bin2d() is usually more appropriate. A bubblechart is a scatterplot with a third variable mapped to the size of points.

geom_point(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

stat	
The statistical transformation to use on the data for this layer, as a string.

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

Overplotting
The biggest potential problem with a scatterplot is overplotting: whenever you have more than a few points, points may be plotted on top of one another. This can severely distort the visual appearance of the plot. There is no one solution to this problem, but there are some techniques that can help. You can add additional information with geom_smooth(), geom_quantile() or geom_density_2d(). If you have few unique x values, geom_boxplot() may also be useful.

Alternatively, you can summarise the number of points at each location and display that in some way, using geom_count(), geom_hex(), or geom_density2d().

Another technique is to make the points transparent (e.g. geom_point(alpha = 0.05)) or very small (e.g. geom_point(shape = ".")).

Aesthetics
geom_point() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

shape

size

stroke

Learn more about setting these aesthetics in vignette("cxplot-specs").

Examples
p <- cxplot(mtcars, aes(wt, mpg))
p + geom_point()


# Add aesthetic mappings
p + geom_point(aes(colour = factor(cyl)))

p + geom_point(aes(shape = factor(cyl)))

# A "bubblechart":
p + geom_point(aes(size = qsec))


# Set aesthetics to fixed value
cxplot(mtcars, aes(wt, mpg)) + geom_point(colour = "red", size = 3)


# \donttest{
# Varying alpha is useful for large datasets
d <- cxplot(diamonds, aes(carat, price))
d + geom_point(alpha = 1/10)

d + geom_point(alpha = 1/20)

d + geom_point(alpha = 1/100)

# }

# For shapes that have a border (like 21), you can colour the inside and
# outside separately. Use the stroke aesthetic to modify the width of the
# border
cxplot(mtcars, aes(wt, mpg)) +
  geom_point(shape = 21, colour = "black", fill = "white", size = 5, stroke = 5)


# \donttest{
# You can create interesting shapes by layering multiple points of
# different sizes
p <- cxplot(mtcars, aes(mpg, wt, shape = factor(cyl)))
p +
  geom_point(aes(colour = factor(cyl)), size = 4) +
  geom_point(colour = "grey90", size = 1.5)

p +
  geom_point(colour = "black", size = 4.5) +
  geom_point(colour = "pink", size = 4) +
  geom_point(aes(shape = factor(cyl)))


# geom_point warns when missing values have been dropped from the data set
# and not plotted, you can turn this off by setting na.rm = TRUE
mtcars2 <- transform(mtcars, mpg = ifelse(runif(32) < 0.2, NA, mpg))
cxplot(mtcars2, aes(wt, mpg)) +
  geom_point()
#> Warning: Removed 7 rows containing missing values (geom_point).

cxplot(mtcars2, aes(wt, mpg)) +
  geom_point(na.rm = TRUE)

# }

--
geom_quantile.html
Quantile regression
Source: R/geom-quantile.r, R/stat-quantile.r
This fits a quantile regression to the data and draws the fitted quantiles with lines. This is as a continuous analogue to geom_boxplot().

geom_quantile(
  mapping = NULL,
  data = NULL,
  stat = "quantile",
  position = "identity",
  ...,
  lineend = "butt",
  linejoin = "round",
  linemitre = 10,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_quantile(
  mapping = NULL,
  data = NULL,
  geom = "quantile",
  position = "identity",
  ...,
  quantiles = c(0.25, 0.5, 0.75),
  formula = NULL,
  method = "rq",
  method.args = list(),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

lineend	
Line end style (round, butt, square).

linejoin	
Line join style (round, mitre, bevel).

linemitre	
Line mitre limit (number greater than 1).

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

geom, stat	
Use to override the default connection between geom_quantile() and stat_quantile().

quantiles	
conditional quantiles of y to calculate and display

formula	
formula relating y variables to x variables

method	
Quantile regression method to use. Available options are "rq" (for quantreg::rq()) and "rqss" (for quantreg::rqss()).

method.args	
List of additional arguments passed on to the modelling function defined by method.

Aesthetics
geom_quantile() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

group

linetype

size

weight

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
quantile
quantile of distribution

Examples
m <-
  cxplot(mpg, aes(displ, 1 / hwy)) +
  geom_point()
m + geom_quantile()
#> Smoothing formula not specified. Using: y ~ x

m + geom_quantile(quantiles = 0.5)
#> Smoothing formula not specified. Using: y ~ x

q10 <- seq(0.05, 0.95, by = 0.05)
m + geom_quantile(quantiles = q10)
#> Smoothing formula not specified. Using: y ~ x


# You can also use rqss to fit smooth quantiles
m + geom_quantile(method = "rqss")
#> Smoothing formula not specified. Using: y ~ qss(x, lambda = 1)

# Note that rqss doesn't pick a smoothing constant automatically, so
# you'll need to tweak lambda yourself
m + geom_quantile(method = "rqss", lambda = 0.1)
#> Smoothing formula not specified. Using: y ~ qss(x, lambda = 0.1)


# Set aesthetics to fixed value
m + geom_quantile(colour = "red", size = 2, alpha = 0.5)
#> Smoothing formula not specified. Using: y ~ x

--
geom_rug.html
Rug plots in the margins
Source: R/geom-rug.r
A rug plot is a compact visualisation designed to supplement a 2d display with the two 1d marginal distributions. Rug plots display individual cases so are best used with smaller datasets.

geom_rug(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  outside = FALSE,
  sides = "bl",
  length = unit(0.03, "npc"),
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

stat	
The statistical transformation to use on the data for this layer, as a string.

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

outside	
logical that controls whether to move the rug tassels outside of the plot area. Default is off (FALSE). You will also need to use coord_cartesian(clip = "off"). When set to TRUE, also consider changing the sides argument to "tr". See examples.

sides	
A string that controls which sides of the plot the rugs appear on. It can be set to a string containing any of "trbl", for top, right, bottom, and left.

length	
A grid::unit() object that sets the length of the rug lines. Use scale expansion to avoid overplotting of data.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

Details
By default, the rug lines are drawn with a length that corresponds to 3% of the total plot size. Since the default scale expansion of for continuous variables is 5% at both ends of the scale, the rug will not overlap with any data points under the default settings.

Aesthetics
geom_rug() understands the following aesthetics (required aesthetics are in bold):

alpha

colour

group

linetype

size

x

y

Learn more about setting these aesthetics in vignette("cxplot-specs").

Examples
p <- cxplot(mtcars, aes(wt, mpg)) +
  geom_point()
p

p + geom_rug()

p + geom_rug(sides="b")    # Rug on bottom only

p + geom_rug(sides="trbl") # All four sides


# Use jittering to avoid overplotting for smaller datasets
cxplot(mpg, aes(displ, cty)) +
  geom_point() +
  geom_rug()


cxplot(mpg, aes(displ, cty)) +
  geom_jitter() +
  geom_rug(alpha = 1/2, position = "jitter")


# move the rug tassels to outside the plot
# remember to set clip = "off".
p +
  geom_rug(outside = TRUE) +
  coord_cartesian(clip = "off")


# set sides to top right, and then move the margins
p +
  geom_rug(outside = TRUE, sides = "tr") +
  coord_cartesian(clip = "off") +
  theme(plot.margin = margin(1, 1, 1, 1, "cm"))


# increase the line length and
# expand axis to avoid overplotting
p +
  geom_rug(length = unit(0.05, "npc")) +
  scale_y_continuous(expand = c(0.1, 0.1))

--
geom_smooth.html
Smoothed conditional means
Source: R/geom-smooth.r, R/stat-smooth.r
Aids the eye in seeing patterns in the presence of overplotting. geom_smooth() and stat_smooth() are effectively aliases: they both use the same arguments. Use stat_smooth() if you want to display the results with a non-standard geom.

geom_smooth(
  mapping = NULL,
  data = NULL,
  stat = "smooth",
  position = "identity",
  ...,
  method = NULL,
  formula = NULL,
  se = TRUE,
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_smooth(
  mapping = NULL,
  data = NULL,
  geom = "smooth",
  position = "identity",
  ...,
  method = NULL,
  formula = NULL,
  se = TRUE,
  n = 80,
  span = 0.75,
  fullrange = FALSE,
  level = 0.95,
  method.args = list(),
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

method	
Smoothing method (function) to use, accepts either NULL or a character vector, e.g. "lm", "glm", "gam", "loess" or a function, e.g. MASS::rlm or mgcv::gam, stats::lm, or stats::loess. "auto" is also accepted for backwards compatibility. It is equivalent to NULL.

For method = NULL the smoothing method is chosen based on the size of the largest group (across all panels). stats::loess() is used for less than 1,000 observations; otherwise mgcv::gam() is used with formula = y ~ s(x, bs = "cs") with method = "REML". Somewhat anecdotally, loess gives a better appearance, but is (2) in memory, so does not work for larger datasets.

If you have fewer than 1,000 observations but want to use the same gam() model that method = NULL would use, then set method = "gam", formula = y ~ s(x, bs = "cs").

formula	
Formula to use in smoothing function, eg. y ~ x, y ~ poly(x, 2), y ~ log(x). NULL by default, in which case method = NULL implies formula = y ~ x when there are fewer than 1,000 observations and formula = y ~ s(x, bs = "cs") otherwise.

se	
Display confidence interval around smooth? (TRUE by default, see level to control.)

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

orientation	
The orientation of the layer. The default (NA) automatically determines the orientation from the aesthetic mapping. In the rare event that this fails it can be given explicitly by setting orientation to either "x" or "y". See the Orientation section for more detail.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

geom, stat	
Use to override the default connection between geom_smooth() and stat_smooth().

n	
Number of points at which to evaluate smoother.

span	
Controls the amount of smoothing for the default loess smoother. Smaller numbers produce wigglier lines, larger numbers produce smoother lines. Only used with loess, i.e. when method = "loess", or when method = NULL (the default) and there are fewer than 1,000 observations.

fullrange	
Should the fit span the full range of the plot, or just the data?

level	
Level of confidence interval to use (0.95 by default).

method.args	
List of additional arguments passed on to the modelling function defined by method.

Details
Calculation is performed by the (currently undocumented) predictdf() generic and its methods. For most methods the standard error bounds are computed using the predict() method -- the exceptions are loess(), which uses a t-based approximation, and glm(), where the normal confidence interval is constructed on the link scale and then back-transformed to the response scale.

Orientation
This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, cxplot will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the orientation parameter, which can be either "x" or "y". The value gives the axis that the geom should run along, "x" being the default orientation you would expect for the geom.

Aesthetics
geom_smooth() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

linetype

size

weight

ymax

ymin

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
stat_smooth() provides the following variables, some of which depend on the orientation:

y or x
predicted value

ymin or xmin
lower pointwise confidence interval around the mean

ymax or xmax
upper pointwise confidence interval around the mean

se
standard error

See also
See individual modelling functions for more details: lm() for linear smooths, glm() for generalised linear smooths, and loess() for local smooths.

Examples
cxplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth()
#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'


# If you need the fitting to be done along the y-axis set the orientation
cxplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(orientation = "y")
#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'


# Use span to control the "wiggliness" of the default loess smoother.
# The span is the fraction of points used to fit each local regression:
# small numbers make a wigglier curve, larger numbers make a smoother curve.
cxplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(span = 0.3)
#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'


# Instead of a loess smooth, you can use any other modelling function:
cxplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(method = lm, se = FALSE)
#> `geom_smooth()` using formula 'y ~ x'


cxplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(method = lm, formula = y ~ splines::bs(x, 3), se = FALSE)


# Smooths are automatically fit to each group (defined by categorical
# aesthetics or the group aesthetic) and for each facet.

cxplot(mpg, aes(displ, hwy, colour = class)) +
  geom_point() +
  geom_smooth(se = FALSE, method = lm)
#> `geom_smooth()` using formula 'y ~ x'

cxplot(mpg, aes(displ, hwy)) +
  geom_point() +
  geom_smooth(span = 0.8) +
  facet_wrap(~drv)
#> `geom_smooth()` using method = 'loess' and formula 'y ~ x'


# \donttest{
binomial_smooth <- function(...) {
  geom_smooth(method = "glm", method.args = list(family = "binomial"), ...)
}
# To fit a logistic regression, you need to coerce the values to
# a numeric vector lying between 0 and 1.
cxplot(rpart::kyphosis, aes(Age, Kyphosis)) +
  geom_jitter(height = 0.05) +
  binomial_smooth()
#> `geom_smooth()` using formula 'y ~ x'
#> Warning: Computation failed in `stat_smooth()`:
#> y values must be 0 <= y <= 1


cxplot(rpart::kyphosis, aes(Age, as.numeric(Kyphosis) - 1)) +
  geom_jitter(height = 0.05) +
  binomial_smooth()
#> `geom_smooth()` using formula 'y ~ x'


cxplot(rpart::kyphosis, aes(Age, as.numeric(Kyphosis) - 1)) +
  geom_jitter(height = 0.05) +
  binomial_smooth(formula = y ~ splines::ns(x, 2))


# But in this case, it's probably better to fit the model yourself
# so you can exercise more control and see whether or not it's a good model.
# }

--
geom_text.html
Text
Source: R/geom-label.R, R/geom-text.r
Text geoms are useful for labeling plots. They can be used by themselves as scatterplots or in combination with other geoms, for example, for labeling points or for annotating the height of bars. geom_text() adds only text to the plot. geom_label() draws a rectangle behind the text, making it easier to read.

geom_label(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  label.padding = unit(0.25, "lines"),
  label.r = unit(0.15, "lines"),
  label.size = 0.25,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_text(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  parse = FALSE,
  nudge_x = 0,
  nudge_y = 0,
  check_overlap = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

stat	
The statistical transformation to use on the data for this layer, as a string.

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function. Cannot be jointy specified with nudge_x or nudge_y.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

parse	
If TRUE, the labels will be parsed into expressions and displayed as described in ?plotmath.

nudge_x, nudge_y	
Horizontal and vertical adjustment to nudge labels by. Useful for offsetting text from points, particularly on discrete scales. Cannot be jointly specified with position.

label.padding	
Amount of padding around label. Defaults to 0.25 lines.

label.r	
Radius of rounded corners. Defaults to 0.15 lines.

label.size	
Size of label border, in mm.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

check_overlap	
If TRUE, text that overlaps previous text in the same layer will not be plotted. check_overlap happens at draw time and in the order of the data. Therefore data should be arranged by the label column before calling geom_text(). Note that this argument is not supported by geom_label().

Details
Note that when you resize a plot, text labels stay the same size, even though the size of the plot area changes. This happens because the "width" and "height" of a text element are 0. Obviously, text labels do have height and width, but they are physical units, not data units. For the same reason, stacking and dodging text will not work by default, and axis limits are not automatically expanded to include all text.

geom_text() and geom_label() add labels for each row in the data, even if coordinates x, y are set to single values in the call to geom_label() or geom_text(). To add labels at specified points use annotate() with annotate(geom = "text", ...) or annotate(geom = "label", ...).

To automatically position non-overlapping text labels see the ggrepel package.

Aesthetics
geom_text() understands the following aesthetics (required aesthetics are in bold):

x

y

label

alpha

angle

colour

family

fontface

group

hjust

lineheight

size

vjust

Learn more about setting these aesthetics in vignette("cxplot-specs").

geom_label()
Currently geom_label() does not support the check_overlap argument or the angle aesthetic. Also, it is considerably slower than geom_text(). The fill aesthetic controls the background colour of the label.

Alignment
You can modify text alignment with the vjust and hjust aesthetics. These can either be a number between 0 (right/bottom) and 1 (top/left) or a character ("left", "middle", "right", "bottom", "center", "top"). There are two special alignments: "inward" and "outward". Inward always aligns text towards the center, and outward aligns it away from the center.

Examples
p <- cxplot(mtcars, aes(wt, mpg, label = rownames(mtcars)))

p + geom_text()

# Avoid overlaps
p + geom_text(check_overlap = TRUE)

# Labels with background
p + geom_label()

# Change size of the label
p + geom_text(size = 10)


# Set aesthetics to fixed value
p +
  geom_point() +
  geom_text(hjust = 0, nudge_x = 0.05)

p +
  geom_point() +
  geom_text(vjust = 0, nudge_y = 0.5)

p +
  geom_point() +
  geom_text(angle = 45)

if (FALSE) {
# Doesn't work on all systems
p +
  geom_text(family = "Times New Roman")
}

# Add aesthetic mappings
p + geom_text(aes(colour = factor(cyl)))

p + geom_text(aes(colour = factor(cyl))) +
  scale_colour_discrete(l = 40)

p + geom_label(aes(fill = factor(cyl)), colour = "white", fontface = "bold")


p + geom_text(aes(size = wt))

# Scale height of text, rather than sqrt(height)
p +
  geom_text(aes(size = wt)) +
  scale_radius(range = c(3,6))


# You can display expressions by setting parse = TRUE.  The
# details of the display are described in ?plotmath, but note that
# geom_text uses strings, not expressions.
p +
  geom_text(
    aes(label = paste(wt, "^(", cyl, ")", sep = "")),
    parse = TRUE
  )


# Add a text annotation
p +
  geom_text() +
  annotate(
    "text", label = "plot mpg vs. wt",
    x = 2, y = 15, size = 8, colour = "red"
  )


# \donttest{
# Aligning labels and bars --------------------------------------------------
df <- data.frame(
  x = factor(c(1, 1, 2, 2)),
  y = c(1, 3, 2, 1),
  grp = c("a", "b", "a", "b")
)

# cxplot doesn't know you want to give the labels the same virtual width
# as the bars:
cxplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp), position = "dodge") +
  geom_text(aes(label = y), position = "dodge")
#> Warning: Width not defined. Set with `position_dodge(width = ?)`

# So tell it:
cxplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp), position = "dodge") +
  geom_text(aes(label = y), position = position_dodge(0.9))

# Use you can't nudge and dodge text, so instead adjust the y position
cxplot(data = df, aes(x, y, group = grp)) +
  geom_col(aes(fill = grp), position = "dodge") +
  geom_text(
    aes(label = y, y = y + 0.05),
    position = position_dodge(0.9),
    vjust = 0
  )


# To place text in the middle of each bar in a stacked barplot, you
# need to set the vjust parameter of position_stack()
cxplot(data = df, aes(x, y, group = grp)) +
 geom_col(aes(fill = grp)) +
 geom_text(aes(label = y), position = position_stack(vjust = 0.5))


# Justification -------------------------------------------------------------
df <- data.frame(
  x = c(1, 1, 2, 2, 1.5),
  y = c(1, 2, 1, 2, 1.5),
  text = c("bottom-left", "bottom-right", "top-left", "top-right", "center")
)
cxplot(df, aes(x, y)) +
  geom_text(aes(label = text))

cxplot(df, aes(x, y)) +
  geom_text(aes(label = text), vjust = "inward", hjust = "inward")

# }

--
geom_tile.html
Rectangles
Source: R/geom-raster.r, R/geom-rect.r, R/geom-tile.r
geom_rect() and geom_tile() do the same thing, but are parameterised differently: geom_rect() uses the locations of the four corners (xmin, xmax, ymin and ymax), while geom_tile() uses the center of the tile and its size (x, y, width, height). geom_raster() is a high performance special case for when all the tiles are the same size.

geom_raster(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  hjust = 0.5,
  vjust = 0.5,
  interpolate = FALSE,
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_rect(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  linejoin = "mitre",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)

geom_tile(
  mapping = NULL,
  data = NULL,
  stat = "identity",
  position = "identity",
  ...,
  linejoin = "mitre",
  na.rm = FALSE,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

stat	
The statistical transformation to use on the data for this layer, as a string.

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

hjust, vjust	
horizontal and vertical justification of the grob. Each justification value should be a number between 0 and 1. Defaults to 0.5 for both, centering each pixel over its data location.

interpolate	
If TRUE interpolate linearly, if FALSE (the default) don't interpolate.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

linejoin	
Line join style (round, mitre, bevel).

Aesthetics
geom_tile() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

height

linetype

size

width

Learn more about setting these aesthetics in vignette("cxplot-specs").

Examples
# The most common use for rectangles is to draw a surface. You always want
# to use geom_raster here because it's so much faster, and produces
# smaller output when saving to PDF
cxplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density))


# Interpolation smooths the surface & is most helpful when rendering images.
cxplot(faithfuld, aes(waiting, eruptions)) +
 geom_raster(aes(fill = density), interpolate = TRUE)


# If you want to draw arbitrary rectangles, use geom_tile() or geom_rect()
df <- data.frame(
  x = rep(c(2, 5, 7, 9, 12), 2),
  y = rep(c(1, 2), each = 5),
  z = factor(rep(1:5, each = 2)),
  w = rep(diff(c(0, 4, 6, 8, 10, 14)), 2)
)
cxplot(df, aes(x, y)) +
  geom_tile(aes(fill = z), colour = "grey50")

cxplot(df, aes(x, y, width = w)) +
  geom_tile(aes(fill = z), colour = "grey50")

cxplot(df, aes(xmin = x - w / 2, xmax = x + w / 2, ymin = y, ymax = y + 1)) +
  geom_rect(aes(fill = z), colour = "grey50")


# \donttest{
# Justification controls where the cells are anchored
df <- expand.grid(x = 0:5, y = 0:5)
df$z <- runif(nrow(df))
# default is compatible with geom_tile()
cxplot(df, aes(x, y, fill = z)) +
  geom_raster()

# zero padding
cxplot(df, aes(x, y, fill = z)) +
  geom_raster(hjust = 0, vjust = 0)


# Inspired by the image-density plots of Ken Knoblauch
cars <- cxplot(mtcars, aes(mpg, factor(cyl)))
cars + geom_point()

cars + stat_bin2d(aes(fill = after_stat(count)), binwidth = c(3,1))

cars + stat_bin2d(aes(fill = after_stat(density)), binwidth = c(3,1))


cars +
  stat_density(
    aes(fill = after_stat(density)),
    geom = "raster",
    position = "identity"
   )

cars +
  stat_density(
    aes(fill = after_stat(count)),
    geom = "raster",
    position = "identity"
  )

# }

--
geom_violin.html
Violin plot
Source: R/geom-violin.r, R/stat-ydensity.r
A violin plot is a compact display of a continuous distribution. It is a blend of geom_boxplot() and geom_density(): a violin plot is a mirrored density plot displayed in the same way as a boxplot.

geom_violin(
  mapping = NULL,
  data = NULL,
  stat = "ydensity",
  position = "dodge",
  ...,
  draw_quantiles = NULL,
  trim = TRUE,
  scale = "area",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)

stat_ydensity(
  mapping = NULL,
  data = NULL,
  geom = "violin",
  position = "dodge",
  ...,
  bw = "nrd0",
  adjust = 1,
  kernel = "gaussian",
  trim = TRUE,
  scale = "area",
  na.rm = FALSE,
  orientation = NA,
  show.legend = NA,
  inherit.aes = TRUE
)
Arguments
mapping	
Set of aesthetic mappings created by aes() or aes_(). If specified and inherit.aes = TRUE (the default), it is combined with the default mapping at the top level of the plot. You must supply mapping if there is no plot mapping.

data	
The data to be displayed in this layer. There are three options:

If NULL, the default, the data is inherited from the plot data as specified in the call to cxplot().

A data.frame, or other object, will override the plot data. All objects will be fortified to produce a data frame. See fortify() for which variables will be created.

A function will be called with a single argument, the plot data. The return value must be a data.frame, and will be used as the layer data. A function can be created from a formula (e.g. ~ head(.x, 10)).

position	
Position adjustment, either as a string, or the result of a call to a position adjustment function.

...	
Other arguments passed on to layer(). These are often aesthetics, used to set an aesthetic to a fixed value, like colour = "red" or size = 3. They may also be parameters to the paired geom/stat.

draw_quantiles	
If not(NULL) (default), draw horizontal lines at the given quantiles of the density estimate.

trim	
If TRUE (default), trim the tails of the violins to the range of the data. If FALSE, don't trim the tails.

scale	
if "area" (default), all violins have the same area (before trimming the tails). If "count", areas are scaled proportionally to the number of observations. If "width", all violins have the same maximum width.

na.rm	
If FALSE, the default, missing values are removed with a warning. If TRUE, missing values are silently removed.

orientation	
The orientation of the layer. The default (NA) automatically determines the orientation from the aesthetic mapping. In the rare event that this fails it can be given explicitly by setting orientation to either "x" or "y". See the Orientation section for more detail.

show.legend	
logical. Should this layer be included in the legends? NA, the default, includes if any aesthetics are mapped. FALSE never includes, and TRUE always includes. It can also be a named logical vector to finely select the aesthetics to display.

inherit.aes	
If FALSE, overrides the default aesthetics, rather than combining with them. This is most useful for helper functions that define both data and aesthetics and shouldn't inherit behaviour from the default plot specification, e.g. borders().

geom, stat	
Use to override the default connection between geom_violin() and stat_ydensity().

bw	
The smoothing bandwidth to be used. If numeric, the standard deviation of the smoothing kernel. If character, a rule to choose the bandwidth, as listed in stats::bw.nrd().

adjust	
A multiplicate bandwidth adjustment. This makes it possible to adjust the bandwidth while still using the a bandwidth estimator. For example, adjust = 1/2 means use half of the default bandwidth.

kernel	
Kernel. See list of available kernels in density().

Orientation
This geom treats each axis differently and, thus, can thus have two orientations. Often the orientation is easy to deduce from a combination of the given mappings and the types of positional scales in use. Thus, cxplot will by default try to guess which orientation the layer should have. Under rare circumstances, the orientation is ambiguous and guessing may fail. In that case the orientation can be specified directly using the orientation parameter, which can be either "x" or "y". The value gives the axis that the geom should run along, "x" being the default orientation you would expect for the geom.

Aesthetics
geom_violin() understands the following aesthetics (required aesthetics are in bold):

x

y

alpha

colour

fill

group

linetype

size

weight

Learn more about setting these aesthetics in vignette("cxplot-specs").

Computed variables
density
density estimate

scaled
density estimate, scaled to maximum of 1

count
density * number of points - probably useless for violin plots

violinwidth
density scaled for the violin plot, according to area, counts or to a constant maximum width

n
number of points

width
width of violin bounding box

References
Hintze, J. L., Nelson, R. D. (1998) Violin Plots: A Box Plot-Density Trace Synergism. The American Statistician 52, 181-184.

See also
geom_violin() for examples, and stat_density() for examples with data along the x axis.

Examples
p <- cxplot(mtcars, aes(factor(cyl), mpg))
p + geom_violin()


# Orientation follows the discrete axis
cxplot(mtcars, aes(mpg, factor(cyl))) +
  geom_violin()


# \donttest{
p + geom_violin() + geom_jitter(height = 0, width = 0.1)


# Scale maximum width proportional to sample size:
p + geom_violin(scale = "count")


# Scale maximum width to 1 for all violins:
p + geom_violin(scale = "width")


# Default is to trim violins to the range of the data. To disable:
p + geom_violin(trim = FALSE)


# Use a smaller bandwidth for closer density fit (default is 1).
p + geom_violin(adjust = .5)


# Add aesthetic mappings
# Note that violins are automatically dodged when any aesthetic is
# a factor
p + geom_violin(aes(fill = cyl))

p + geom_violin(aes(fill = factor(cyl)))

p + geom_violin(aes(fill = factor(vs)))
#> Warning: Groups with fewer than two data points have been dropped.

p + geom_violin(aes(fill = factor(am)))


# Set aesthetics to fixed value
p + geom_violin(fill = "grey80", colour = "#3366FF")


# Show quartiles
p + geom_violin(draw_quantiles = c(0.25, 0.5, 0.75))


# Scales vs. coordinate transforms -------
if (require("cxplotmovies")) {
# Scale transformations occur before the density statistics are computed.
# Coordinate transformations occur afterwards.  Observe the effect on the
# number of outliers.
m <- cxplot(movies, aes(y = votes, x = rating, group = cut_width(rating, 0.5)))
m + geom_violin()
m +
  geom_violin() +
  scale_y_log10()
m +
  geom_violin() +
  coord_trans(y = "log10")
m +
  geom_violin() +
  scale_y_log10() + coord_trans(y = "log10")

# Violin plots with continuous x:
# Use the group aesthetic to group observations in violins
cxplot(movies, aes(year, budget)) +
  geom_violin()
cxplot(movies, aes(year, budget)) +
  geom_violin(aes(group = cut_width(year, 10)), scale = "width")
}
#> Warning: Removed 53573 rows containing non-finite values (stat_ydensity).
#> Warning: Groups with fewer than two data points have been dropped.

# }

--
cxplot.html
Create a new cxplot
Source: R/plot.r
cxplot() initializes a cxplot object. It can be used to declare the input data frame for a graphic and to specify the set of plot aesthetics intended to be common throughout all subsequent layers unless specifically overridden.

cxplot(data = NULL, mapping = aes(), ..., environment = parent.frame())
Arguments
data	
Default dataset to use for plot. If not already a data.frame, will be converted to one by fortify(). If not specified, must be supplied in each layer added to the plot.

mapping	
Default list of aesthetic mappings to use for plot. If not specified, must be supplied in each layer added to the plot.

Details
cxplot() is used to construct the initial plot object, and is almost always followed by + to add component to the plot. There are three common ways to invoke cxplot():

cxplot(df, aes(x, y, other aesthetics))

cxplot(df)

cxplot()

The first method is recommended if all layers use the same data and the same set of aesthetics, although this method can also be used to add a layer using data from another data frame. See the first example below. The second method specifies the default data frame to use for the plot, but no aesthetics are defined up front. This is useful when one data frame is used predominantly as layers are added, but the aesthetics may vary from one layer to another. The third method initializes a skeleton cxplot object which is fleshed out as layers are added. This method is useful when multiple data frames are used to produce different layers, as is often the case in complex graphics.

Examples
# Generate some sample data, then compute mean and standard deviation
# in each group
df <- data.frame(
  gp = factor(rep(letters[1:3], each = 10)),
  y = rnorm(30)
)
ds <- do.call(rbind, lapply(split(df, df$gp), function(d) {
  data.frame(mean = mean(d$y), sd = sd(d$y), gp = d$gp)
}))

# The summary data frame ds is used to plot larger red points on top
# of the raw data. Note that we don't need to supply `data` or `mapping`
# in each layer because the defaults from cxplot() are used.
cxplot(df, aes(gp, y)) +
  geom_point() +
  geom_point(data = ds, aes(y = mean), colour = 'red', size = 3)


# Same plot as above, declaring only the data frame in cxplot().
# Note how the x and y aesthetics must now be declared in
# each geom_point() layer.
cxplot(df) +
  geom_point(aes(gp, y)) +
  geom_point(data = ds, aes(gp, mean), colour = 'red', size = 3)


# Alternatively we can fully specify the plot in each layer. This
# is not useful here, but can be more clear when working with complex
# mult-dataset graphics
cxplot() +
  geom_point(data = df, aes(gp, y)) +
  geom_point(data = ds, aes(gp, mean), colour = 'red', size = 3) +
  geom_errorbar(
    data = ds,
    aes(gp, mean, ymin = mean - sd, ymax = mean + sd),
    colour = 'red',
    width = 0.4
  )

--
aes.html
Construct aesthetic mappings
Source: R/aes.r
Aesthetic mappings describe how variables in the data are mapped to visual properties (aesthetics) of geoms. Aesthetic mappings can be set in cxplot() and in individual layers.

aes(x, y, ...)
Arguments
x, y, ...	
List of name-value pairs in the form aesthetic = variable describing which variables in the layer data should be mapped to which aesthetics used by the paired geom/stat. The expression variable is evaluated within the layer data, so there is no need to refer to the original dataset (i.e., use cxplot(df, aes(variable)) instead of cxplot(df, aes(df$variable))). The names for x and y aesthetics are typically omitted because they are so common; all other aesthetics must be named.

Value
A list with class uneval. Components of the list are either quosures or constants.

Details
This function also standardises aesthetic names by converting color to colour (also in substrings, e.g., point_color to point_colour) and translating old style R names to cxplot names (e.g., pch to shape and cex to size).

See also
vars() for another quoting function designed for faceting specifications.

Examples
aes(x = mpg, y = wt)
#> Aesthetic mapping: 
#> * `x` -> `mpg`
#> * `y` -> `wt`
aes(mpg, wt)
#> Aesthetic mapping: 
#> * `x` -> `mpg`
#> * `y` -> `wt`

# You can also map aesthetics to functions of variables
aes(x = mpg ^ 2, y = wt / cyl)
#> Aesthetic mapping: 
#> * `x` -> `mpg^2`
#> * `y` -> `wt/cyl`

# Or to constants
aes(x = 1, colour = "smooth")
#> Aesthetic mapping: 
#> * `x`      -> 1
#> * `colour` -> "smooth"

# Aesthetic names are automatically standardised
aes(col = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`
aes(fg = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`
aes(color = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`
aes(colour = x)
#> Aesthetic mapping: 
#> * `colour` -> `x`

# aes() is passed to either cxplot() or specific layer. Aesthetics supplied
# to cxplot() are used as defaults for every layer.
cxplot(mpg, aes(displ, hwy)) + geom_point()

cxplot(mpg) + geom_point(aes(displ, hwy))


# Tidy evaluation ----------------------------------------------------
# aes() automatically quotes all its arguments, so you need to use tidy
# evaluation to create wrappers around cxplot pipelines. The
# simplest case occurs when your wrapper takes dots:
scatter_by <- function(data, ...) {
  cxplot(data) + geom_point(aes(...))
}
scatter_by(mtcars, disp, drat)


# If your wrapper has a more specific interface with named arguments,
# you need "enquote and unquote":
scatter_by <- function(data, x, y) {
  x <- enquo(x)
  y <- enquo(y)

  cxplot(data) + geom_point(aes(!!x, !!y))
}
scatter_by(mtcars, disp, drat)


# Note that users of your wrapper can use their own functions in the
# quoted expressions and all will resolve as it should!
cut3 <- function(x) cut_number(x, 3)
scatter_by(mtcars, cut3(disp), drat)
